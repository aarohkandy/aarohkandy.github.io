<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Stickman - Matter.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            cursor: crosshair;
        }
        
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            z-index: 1000;
            pointer-events: none;
        }
        
        #info h3 {
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        #info p {
            margin: 4px 0;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <h3>Interactive Stickman</h3>
        <p>Move your cursor near the stickman to interact</p>
        <p id="state-display">State: PAUSED</p>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        // Matter.js aliases
        const Engine = Matter.Engine;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Constraint = Matter.Constraint;
        const Composite = Matter.Composite;
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const stateDisplay = document.getElementById('state-display');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        
        // Matter.js engine
        const engine = Engine.create();
        engine.world.gravity.y = 1;
        engine.world.gravity.scale = 0.001;
        
        // Ground and walls
        let ground, leftWall, rightWall;
        
        function createBoundaries() {
            // Ground
            ground = Bodies.rectangle(
                window.innerWidth / 2,
                window.innerHeight - 5,
                window.innerWidth,
                10,
                { isStatic: true, render: { fillStyle: '#2c3e50' } }
            );
            
            // Left and right walls to prevent escape
            leftWall = Bodies.rectangle(
                5,
                window.innerHeight / 2,
                10,
                window.innerHeight,
                { isStatic: true, render: { visible: false } }
            );
            
            rightWall = Bodies.rectangle(
                window.innerWidth - 5,
                window.innerHeight / 2,
                10,
                window.innerHeight,
                { isStatic: true, render: { visible: false } }
            );
            
            World.add(engine.world, [ground, leftWall, rightWall]);
        }
        
        createBoundaries();
        
        // Stickman body parts (simple stickman)
        const parts = {
            head: null,
            torso: null,
            leftArm: null,
            rightArm: null,
            leftLeg: null,
            rightLeg: null
        };
        
        // Constraints (joints)
        const joints = {
            neck: null,
            leftShoulder: null,
            rightShoulder: null,
            leftHip: null,
            rightHip: null
        };
        
        // Create stickman
        function createStickman(x, y) {
            const headRadius = 20;
            const torsoWidth = 15;
            const torsoHeight = 60;
            const armLength = 50;
            const armWidth = 4;
            const legLength = 60;
            const legWidth = 4;
            
            // Head
            parts.head = Bodies.circle(x, y - 50, headRadius, {
                density: 0.002,
                frictionAir: 0.01
            });
            
            // Torso
            parts.torso = Bodies.rectangle(x, y, torsoWidth, torsoHeight, {
                density: 0.001,
                frictionAir: 0.01
            });
            
            // Left arm (straight)
            parts.leftArm = Bodies.rectangle(x - 20, y - 10, armWidth, armLength, {
                density: 0.0008,
                frictionAir: 0.01
            });
            
            // Right arm (straight)
            parts.rightArm = Bodies.rectangle(x + 20, y - 10, armWidth, armLength, {
                density: 0.0008,
                frictionAir: 0.01
            });
            
            // Left leg (straight)
            parts.leftLeg = Bodies.rectangle(x - 8, y + 50, legWidth, legLength, {
                density: 0.001,
                frictionAir: 0.01
            });
            
            // Right leg (straight)
            parts.rightLeg = Bodies.rectangle(x + 8, y + 50, legWidth, legLength, {
                density: 0.001,
                frictionAir: 0.01
            });
            
            // Add all parts to world
            World.add(engine.world, [
                parts.head, parts.torso,
                parts.leftArm, parts.rightArm,
                parts.leftLeg, parts.rightLeg
            ]);
            
            // Create joints (simple stickman - no elbows or knees)
            joints.neck = Constraint.create({
                bodyA: parts.head,
                bodyB: parts.torso,
                pointA: { x: 0, y: headRadius },
                pointB: { x: 0, y: -torsoHeight / 2 },
                stiffness: 0.9,
                length: 0,
                render: { visible: false }
            });
            
            joints.leftShoulder = Constraint.create({
                bodyA: parts.torso,
                bodyB: parts.leftArm,
                pointA: { x: -torsoWidth / 2, y: -torsoHeight / 2 + 15 },
                pointB: { x: 0, y: -armLength / 2 },
                stiffness: 0.9,
                length: 0,
                render: { visible: false }
            });
            
            joints.rightShoulder = Constraint.create({
                bodyA: parts.torso,
                bodyB: parts.rightArm,
                pointA: { x: torsoWidth / 2, y: -torsoHeight / 2 + 15 },
                pointB: { x: 0, y: -armLength / 2 },
                stiffness: 0.9,
                length: 0,
                render: { visible: false }
            });
            
            joints.leftHip = Constraint.create({
                bodyA: parts.torso,
                bodyB: parts.leftLeg,
                pointA: { x: -torsoWidth / 2 + 4, y: torsoHeight / 2 },
                pointB: { x: 0, y: -legLength / 2 },
                stiffness: 0.9,
                length: 0,
                render: { visible: false }
            });
            
            joints.rightHip = Constraint.create({
                bodyA: parts.torso,
                bodyB: parts.rightLeg,
                pointA: { x: torsoWidth / 2 - 4, y: torsoHeight / 2 },
                pointB: { x: 0, y: -legLength / 2 },
                stiffness: 0.9,
                length: 0,
                render: { visible: false }
            });
            
            // Add all constraints
            World.add(engine.world, Object.values(joints));
            
            // Set initial angles for standing position
            const uprightAngle = -Math.PI / 2;
            Body.setAngle(parts.torso, uprightAngle);
            Body.setAngle(parts.leftLeg, uprightAngle);
            Body.setAngle(parts.rightLeg, uprightAngle);
            Body.setAngle(parts.leftArm, uprightAngle);
            Body.setAngle(parts.rightArm, uprightAngle);
            
            // Set initial velocities to zero
            Object.values(parts).forEach(part => {
                Body.setVelocity(part, { x: 0, y: 0 });
                Body.setAngularVelocity(part, 0);
            });
        }
        
        // Initialize stickman at center bottom
        const startX = window.innerWidth / 2;
        const startY = window.innerHeight - 100;
        createStickman(startX, startY);
        
        // State machine
        let state = 'PAUSED';
        let stateTimer = 0;
        let walkTarget = 0;
        let isRunning = false;
        let standUpPhase = 0;
        let standUpTimer = 0;
        
        // Cursor tracking
        let cursorX = 0;
        let cursorY = 0;
        
        canvas.addEventListener('mousemove', (e) => {
            cursorX = e.clientX;
            cursorY = e.clientY;
        });
        
        // Helper: Get distance from cursor to torso
        function getCursorDistance() {
            const dx = cursorX - parts.torso.position.x;
            const dy = cursorY - parts.torso.position.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Helper: Get angle between two bodies
        function getAngleBetween(bodyA, bodyB) {
            const angleA = bodyA.angle;
            const angleB = bodyB.angle;
            let diff = angleB - angleA;
            if (diff > Math.PI) diff -= Math.PI * 2;
            if (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }
        
        // Helper: Apply angle correction
        function applyAngleCorrection(body, targetAngle, strength = 0.1) {
            const currentAngle = body.angle;
            let diff = targetAngle - currentAngle;
            if (diff > Math.PI) diff -= Math.PI * 2;
            if (diff < -Math.PI) diff += Math.PI * 2;
            Body.setAngularVelocity(body, diff * strength);
        }
        
        // No angle limits needed for simple stickman (no elbows or knees)
        
        // Pick walk target
        function pickWalkTarget() {
            const currentX = parts.torso.position.x;
            const rand = Math.random();
            
            if (rand < 0.3) {
                // Short walk
                walkTarget = currentX + (Math.random() - 0.5) * 200;
            } else if (rand < 0.8) {
                // Medium walk
                walkTarget = currentX + (Math.random() - 0.5) * 550;
            } else {
                // Long walk toward edge
                walkTarget = Math.random() < 0.5 ? 100 : window.innerWidth - 100;
            }
            
            // Clamp to screen bounds
            walkTarget = Math.max(50, Math.min(window.innerWidth - 50, walkTarget));
            
            // 20% chance of running
            isRunning = Math.random() < 0.2;
        }
        
        // Check cursor collision
        function checkCursorCollision() {
            if (state === 'KNOCKED_DOWN' || state === 'STANDING_UP') return;
            
            const distance = getCursorDistance();
            if (distance < 50) {
                // Knock down
                const dx = cursorX - parts.torso.position.x;
                const dy = cursorY - parts.torso.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const pushX = (dx / dist) * 0.05;
                const pushY = (dy / dist) * 0.05;
                
                Body.applyForce(parts.torso, parts.torso.position, { x: pushX, y: pushY });
                Body.setAngularVelocity(parts.torso, (Math.random() - 0.5) * 0.3);
                
                state = 'KNOCKED_DOWN';
                stateTimer = 0;
            }
        }
        
        // State: WALKING
        function updateWalking() {
            const currentX = parts.torso.position.x;
            const direction = walkTarget > currentX ? 1 : -1;
            const distance = Math.abs(walkTarget - currentX);
            
            // Apply horizontal force
            const force = isRunning ? 0.002 : 0.0008;
            Body.applyForce(parts.torso, parts.torso.position, {
                x: force * direction,
                y: 0
            });
            
            // Walking animation
            const animSpeed = isRunning ? 0.3 : 0.15;
            const walkCycle = (stateTimer * animSpeed) % (Math.PI * 2);
            const amplitude = isRunning ? 0.8 : 0.5;
            
            // Base leg angle (vertical when standing)
            const baseLegAngle = -Math.PI / 2;
            
            // Leg swing
            const leftLegSwing = Math.sin(walkCycle) * amplitude;
            const rightLegSwing = Math.sin(walkCycle + Math.PI) * amplitude;
            
            const leftLegTarget = baseLegAngle + leftLegSwing;
            const rightLegTarget = baseLegAngle + rightLegSwing;
            
            applyAngleCorrection(parts.leftLeg, leftLegTarget, 0.12);
            applyAngleCorrection(parts.rightLeg, rightLegTarget, 0.12);
            
            // Arm swing (opposite to legs)
            const leftArmSwing = -rightLegSwing * 0.3;
            const rightArmSwing = -leftLegSwing * 0.3;
            
            const leftArmTarget = baseLegAngle + leftArmSwing;
            const rightArmTarget = baseLegAngle + rightArmSwing;
            
            applyAngleCorrection(parts.leftArm, leftArmTarget, 0.08);
            applyAngleCorrection(parts.rightArm, rightArmTarget, 0.08);
            
            // Torso lean when running
            if (isRunning) {
                const leanAmount = -0.1 * direction;
                applyAngleCorrection(parts.torso, baseLegAngle + leanAmount, 0.05);
            } else {
                applyAngleCorrection(parts.torso, baseLegAngle, 0.03);
            }
            
            // Check if reached target
            if (distance < 10) {
                state = 'PAUSED';
                stateTimer = 0;
            }
        }
        
        // State: PAUSED
        function updatePaused() {
            // Stabilize legs
            const targetLegAngle = -Math.PI / 2;
            applyAngleCorrection(parts.leftLeg, targetLegAngle, 0.05);
            applyAngleCorrection(parts.rightLeg, targetLegAngle, 0.05);
            
            // Breathing animation
            const breath = Math.sin(stateTimer * 0.002) * 0.0001;
            Body.applyForce(parts.torso, parts.torso.position, { x: 0, y: breath });
            
            // Random duration: 30-180 frames
            if (stateTimer > 30 && Math.random() < 0.02) {
                if (stateTimer > 180 || Math.random() < 0.1) {
                    state = 'WALKING';
                    stateTimer = 0;
                    pickWalkTarget();
                }
            }
        }
        
        // State: KNOCKED_DOWN
        function updateKnockedDown() {
            const distance = getCursorDistance();
            const velocity = Math.sqrt(
                parts.torso.velocity.x * parts.torso.velocity.x +
                parts.torso.velocity.y * parts.torso.velocity.y
            );
            
            // Check if cursor comes close again
            if (distance < 50) {
                stateTimer = 0; // Reset timer
                return;
            }
            
            // Transition to standing up when conditions met
            // Try to stand up if cursor is away and body is relatively still
            // Also check if torso is low (on or near ground)
            const torsoY = parts.torso.position.y;
            const groundY = window.innerHeight - 10;
            const isNearGround = (groundY - torsoY) < 150; // Within 150px of ground
            
            if (distance > 100 && velocity < 1.2 && stateTimer > 20 && isNearGround) {
                state = 'STANDING_UP';
                standUpPhase = 0;
                standUpTimer = 0;
            }
        }
        
        // State: STANDING_UP
        function updateStandingUp() {
            // Check if cursor comes close
            if (getCursorDistance() < 50) {
                state = 'KNOCKED_DOWN';
                stateTimer = 0;
                return;
            }
            
            standUpTimer++;
            const uprightAngle = -Math.PI / 2;
            
            // Phase 1: Assess and roll (15 frames)
            if (standUpPhase === 0) {
                const torsoAngle = parts.torso.angle;
                const torsoNormalized = ((torsoAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                const angleDiff = Math.abs(torsoAngle - uprightAngle);
                
                // Roll to side if needed (if on back)
                if (torsoNormalized > Math.PI / 2 && torsoNormalized < Math.PI * 1.5) {
                    // On back, roll to side
                    const rollDir = Math.cos(torsoAngle) > 0 ? 1 : -1;
                    Body.setAngularVelocity(parts.torso, rollDir * 0.2);
                } else if (angleDiff > Math.PI / 4) {
                    // Not upright, try to roll
                    const rollDir = Math.sin(torsoAngle) > 0 ? 1 : -1;
                    Body.setAngularVelocity(parts.torso, rollDir * 0.15);
                }
                
                if (standUpTimer > 15) {
                    standUpPhase = 1;
                    standUpTimer = 0;
                }
            }
            // Phase 2: Push up aggressively (60 frames)
            else if (standUpPhase === 1) {
                // Determine torso orientation
                const torsoAngle = parts.torso.angle;
                const torsoNormalized = ((torsoAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                const isOnBack = torsoNormalized > Math.PI / 2 && torsoNormalized < Math.PI * 1.5;
                
                // Calculate ground position relative to torso
                const groundY = window.innerHeight - 10;
                const torsoY = parts.torso.position.y;
                const distanceToGround = groundY - torsoY;
                
                // Strong upward force to torso
                const forceMultiplier = 1 + (standUpTimer / 60) * 1.5;
                Body.applyForce(parts.torso, parts.torso.position, {
                    x: 0,
                    y: -0.005 * forceMultiplier
                });
                
                // Position legs under torso
                applyAngleCorrection(parts.leftLeg, uprightAngle, 0.25);
                applyAngleCorrection(parts.rightLeg, uprightAngle, 0.25);
                
                // Position arms to reach ground and push up
                // Get shoulder positions accounting for torso rotation
                const cosTorso = Math.cos(parts.torso.angle);
                const sinTorso = Math.sin(parts.torso.angle);
                const shoulderOffsetX = 7.5;
                const shoulderOffsetY = -30; // Top of torso
                
                // Left shoulder world position
                const leftShoulderX = parts.torso.position.x + 
                    (shoulderOffsetX * cosTorso - shoulderOffsetY * sinTorso);
                const leftShoulderY = parts.torso.position.y + 
                    (shoulderOffsetX * sinTorso + shoulderOffsetY * cosTorso);
                
                // Right shoulder world position
                const rightShoulderX = parts.torso.position.x + 
                    (-shoulderOffsetX * cosTorso - shoulderOffsetY * sinTorso);
                const rightShoulderY = parts.torso.position.y + 
                    (-shoulderOffsetX * sinTorso + shoulderOffsetY * cosTorso);
                
                // Calculate where hands should be (on ground, to sides)
                const handOffsetX = 30;
                const leftHandTargetX = parts.torso.position.x - handOffsetX;
                const rightHandTargetX = parts.torso.position.x + handOffsetX;
                const handTargetY = groundY - 3; // Just above ground
                
                // Calculate angles for arms to reach ground
                const leftArmAngle = Math.atan2(
                    handTargetY - leftShoulderY,
                    leftHandTargetX - leftShoulderX
                );
                
                const rightArmAngle = Math.atan2(
                    handTargetY - rightShoulderY,
                    rightHandTargetX - rightShoulderX
                );
                
                // Position arms more aggressively
                applyAngleCorrection(parts.leftArm, leftArmAngle, 0.3);
                applyAngleCorrection(parts.rightArm, rightArmAngle, 0.3);
                
                // Apply upward force at hands (end of arms) to push against ground
                // Calculate hand position (end of arm)
                const armLength = 25; // half of 50px length
                const leftHandX = parts.leftArm.position.x + Math.cos(parts.leftArm.angle) * armLength;
                const leftHandY = parts.leftArm.position.y + Math.sin(parts.leftArm.angle) * armLength;
                const rightHandX = parts.rightArm.position.x + Math.cos(parts.rightArm.angle) * armLength;
                const rightHandY = parts.rightArm.position.y + Math.sin(parts.rightArm.angle) * armLength;
                
                // Only push if hands are near ground
                const handPushForce = 0.004 * forceMultiplier;
                
                if (leftHandY > groundY - 20) {
                    Body.applyForce(parts.leftArm, parts.leftArm.position, { 
                        x: 0, 
                        y: -handPushForce 
                    });
                }
                if (rightHandY > groundY - 20) {
                    Body.applyForce(parts.rightArm, parts.rightArm.position, { 
                        x: 0, 
                        y: -handPushForce 
                    });
                }
                
                if (standUpTimer > 60) {
                    standUpPhase = 2;
                    standUpTimer = 0;
                }
            }
            // Phase 3: Stand & balance (60 frames)
            else if (standUpPhase === 2) {
                // Strong correction to upright
                applyAngleCorrection(parts.torso, uprightAngle, 0.2);
                
                // Legs to vertical
                applyAngleCorrection(parts.leftLeg, uprightAngle, 0.2);
                applyAngleCorrection(parts.rightLeg, uprightAngle, 0.2);
                
                // Arms for balance (spread out)
                const balanceArmAngle = uprightAngle - 0.2;
                applyAngleCorrection(parts.leftArm, balanceArmAngle, 0.1);
                applyAngleCorrection(parts.rightArm, balanceArmAngle, 0.1);
                
                // Check if stable
                const angleDiff = Math.abs(parts.torso.angle - uprightAngle);
                const velocity = Math.sqrt(
                    parts.torso.velocity.x * parts.torso.velocity.x +
                    parts.torso.velocity.y * parts.torso.velocity.y
                );
                
                // Transition to paused when stable
                if (angleDiff < 0.15 && velocity < 0.5 && standUpTimer > 15) {
                    state = 'PAUSED';
                    stateTimer = 0;
                }
                
                // Force transition after max time
                if (standUpTimer > 60) {
                    state = 'PAUSED';
                    stateTimer = 0;
                }
            }
        }
        
        // Helper: Get world position of joint point
        function getJointWorldPosition(body, localPoint) {
            const cos = Math.cos(body.angle);
            const sin = Math.sin(body.angle);
            return {
                x: body.position.x + (localPoint.x * cos - localPoint.y * sin),
                y: body.position.y + (localPoint.x * sin + localPoint.y * cos)
            };
        }
        
        // Helper: Draw line from body center along its angle
        function drawStickLine(body, length) {
            const endX = body.position.x + Math.cos(body.angle) * length;
            const endY = body.position.y + Math.sin(body.angle) * length;
            ctx.beginPath();
            ctx.moveTo(body.position.x, body.position.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        
        function render() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, window.innerHeight - 10, window.innerWidth, 10);
            
            // Draw stickman as simple lines
            ctx.strokeStyle = '#2c3e50';
            ctx.fillStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw head (circle)
            ctx.beginPath();
            ctx.arc(parts.head.position.x, parts.head.position.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Simple face
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(parts.head.position.x - 6, parts.head.position.y - 3, 2, 0, Math.PI * 2);
            ctx.arc(parts.head.position.x + 6, parts.head.position.y - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(parts.head.position.x, parts.head.position.y + 3, 4, 0, Math.PI);
            ctx.stroke();
            ctx.fillStyle = '#ffffff';
            
            // Draw torso (line from neck to hips)
            const neckPos = getJointWorldPosition(parts.torso, joints.neck.pointB);
            const leftHipPos = getJointWorldPosition(parts.torso, joints.leftHip.pointA);
            const rightHipPos = getJointWorldPosition(parts.torso, joints.rightHip.pointA);
            const hipCenterX = (leftHipPos.x + rightHipPos.x) / 2;
            const hipCenterY = (leftHipPos.y + rightHipPos.y) / 2;
            
            ctx.beginPath();
            ctx.moveTo(neckPos.x, neckPos.y);
            ctx.lineTo(hipCenterX, hipCenterY);
            ctx.stroke();
            
            // Draw arms (lines from shoulders to hands)
            const leftShoulderPos = getJointWorldPosition(parts.torso, joints.leftShoulder.pointA);
            const rightShoulderPos = getJointWorldPosition(parts.torso, joints.rightShoulder.pointA);
            const armLength = 50;
            
            // Left arm
            const leftHandX = parts.leftArm.position.x + Math.cos(parts.leftArm.angle) * (armLength / 2);
            const leftHandY = parts.leftArm.position.y + Math.sin(parts.leftArm.angle) * (armLength / 2);
            ctx.beginPath();
            ctx.moveTo(leftShoulderPos.x, leftShoulderPos.y);
            ctx.lineTo(leftHandX, leftHandY);
            ctx.stroke();
            
            // Right arm
            const rightHandX = parts.rightArm.position.x + Math.cos(parts.rightArm.angle) * (armLength / 2);
            const rightHandY = parts.rightArm.position.y + Math.sin(parts.rightArm.angle) * (armLength / 2);
            ctx.beginPath();
            ctx.moveTo(rightShoulderPos.x, rightShoulderPos.y);
            ctx.lineTo(rightHandX, rightHandY);
            ctx.stroke();
            
            // Draw legs (lines from hips to feet)
            const legLength = 60;
            
            // Left leg
            const leftFootX = parts.leftLeg.position.x + Math.cos(parts.leftLeg.angle) * (legLength / 2);
            const leftFootY = parts.leftLeg.position.y + Math.sin(parts.leftLeg.angle) * (legLength / 2);
            ctx.beginPath();
            ctx.moveTo(leftHipPos.x, leftHipPos.y);
            ctx.lineTo(leftFootX, leftFootY);
            ctx.stroke();
            
            // Right leg
            const rightFootX = parts.rightLeg.position.x + Math.cos(parts.rightLeg.angle) * (legLength / 2);
            const rightFootY = parts.rightLeg.position.y + Math.sin(parts.rightLeg.angle) * (legLength / 2);
            ctx.beginPath();
            ctx.moveTo(rightHipPos.x, rightHipPos.y);
            ctx.lineTo(rightFootX, rightFootY);
            ctx.stroke();
        }
        
        // Main loop
        let time = 0;
        
        function loop() {
            time++;
            stateTimer++;
            
            // Update physics
            Engine.update(engine, 1000 / 60);
            
            // Check cursor interaction
            checkCursorCollision();
            
            // Update state machine
            switch (state) {
                case 'WALKING':
                    updateWalking();
                    break;
                case 'PAUSED':
                    updatePaused();
                    break;
                case 'KNOCKED_DOWN':
                    updateKnockedDown();
                    break;
                case 'STANDING_UP':
                    updateStandingUp();
                    break;
            }
            
            // No angle limits for simple stickman
            
            // Render
            render();
            
            // Update state display
            stateDisplay.textContent = `State: ${state}`;
            
            requestAnimationFrame(loop);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            
            // Remove old boundaries
            World.remove(engine.world, [ground, leftWall, rightWall]);
            
            // Create new boundaries
            createBoundaries();
            
            // Adjust walk target if off screen
            if (state === 'WALKING' && (walkTarget < 0 || walkTarget > canvas.width)) {
                pickWalkTarget();
            }
        });
        
        // Start simulation after brief pause
        setTimeout(() => {
            state = 'WALKING';
            pickWalkTarget();
        }, 1000);
        
        // Start loop
        loop();
    </script>
</body>
</html>
