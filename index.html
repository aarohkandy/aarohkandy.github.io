<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Aaroh Kandhare</title>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&amp;family=Playfair+Display:ital,wght@0,400;0,500;0,600;1,400&amp;display=swap"
        rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,container-queries"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="Cubes.css">
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#a35c38",
                        "background-light": "#fdfcf8",
                        "background-dark": "#1a1917",
                        beige: {
                            50: '#fcfbf7',
                            100: '#f7f4ed',
                            200: '#efebd8',
                            300: '#e5dec0',
                            900: '#3e3830',
                        }
                    },
                    fontFamily: {
                        display: ["Playfair Display", "serif"],
                        body: ["Inter", "sans-serif"],
                    },
                    borderRadius: {
                        DEFAULT: "0.5rem",
                        'xl': '1rem',
                        '2xl': '1.5rem',
                        '3xl': '2rem',
                    },
                    animation: {
                        fadeIn: 'fadeIn 0.5s ease-in-out forwards',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        }
                    }
                },
            },
        };
    </script>
    <style>
        body {
            font-family: "Inter", sans-serif;
        }

        .liquid-glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(40px) saturate(200%);
            -webkit-backdrop-filter: blur(40px) saturate(200%);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.15),
                inset 0 1px 1px rgba(255, 255, 255, 0.6),
                inset 0 -1px 1px rgba(255, 255, 255, 0.3);
            animation: fadeIn 0.5s ease-out forwards;
            opacity: 0;
            position: relative;
            overflow: hidden;
        }

        .liquid-glass::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            transition: left 0.5s;
        }

        .liquid-glass:hover::before {
            left: 100%;
        }

        .dark .liquid-glass {
            background: linear-gradient(135deg, 
                rgba(30, 30, 30, 0.5) 0%, 
                rgba(20, 20, 20, 0.3) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(255, 255, 255, 0.05);
        }

        .cubes-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: all;
        }

        .liquid-glass {
            pointer-events: none !important;
        }

        .liquid-glass * {
            pointer-events: auto !important;
        }

        .liquid-glass a {
            pointer-events: auto !important;
        }

        .default-animation {
            width: 100% !important;
            height: 100% !important;
        }

    </style>
</head>

<body
    class="bg-[#E1D9D1] dark:bg-background-dark text-gray-800 dark:text-gray-200 transition-colors duration-300 min-h-screen relative overflow-x-hidden flex flex-col items-center pt-16 md:pt-24 pb-16">
    <div class="cubes-background" id="cubes-root"></div>
    
    <div class="relative z-10 max-w-2xl w-full mx-auto px-6 flex flex-col gap-10">
        <header class="text-center animate-fadeIn" style="animation-duration: 0.3s;">
            <h1
                class="font-display text-5xl md:text-6xl font-medium tracking-tight text-gray-900 dark:text-white italic">
                Aaroh Kandhare
            </h1>
        </header>
        <div class="flex flex-col gap-6">
            <div class="liquid-glass rounded-3xl p-6 md:p-8 transition duration-500 ease-out hover:shadow-xl hover:-translate-y-1"
                style="animation-delay: 0.2s;">
                <p class="text-lg text-gray-800 dark:text-gray-100"><span
                        class="font-display italic text-xl pr-2">Software Engineering:</span> Building scalable and
                    efficient full-stack applications.</p>
            </div>
            <div class="liquid-glass rounded-3xl p-6 md:p-8 transition duration-500 ease-out hover:shadow-xl hover:-translate-y-1"
                style="animation-delay: 0.3s;">
                <p class="text-lg text-gray-800 dark:text-gray-100"><span
                        class="font-display italic text-xl pr-2">Product Management:</span> Bridging technical and
                    business worlds to create impactful products.</p>
            </div>
            <div class="liquid-glass rounded-3xl p-6 md:p-8 transition duration-500 ease-out hover:shadow-xl hover:-translate-y-1"
                style="animation-delay: 0.4s;">
                <p class="text-lg text-gray-800 dark:text-gray-100"><span
                        class="font-display italic text-xl pr-2">Machine Learning:</span> Exploring data to build
                    predictive models and intelligent systems.</p>
            </div>
            <div class="liquid-glass rounded-3xl p-6 md:p-8 transition duration-500 ease-out hover:shadow-xl hover:-translate-y-1"
                style="animation-delay: 0.5s;">
                <p class="text-lg text-gray-800 dark:text-gray-100"><span
                        class="font-display italic text-xl pr-2">Creative Ventures:</span> Pursuing photography and
                    music to explore artistic expression.</p>
            </div>
            <div class="liquid-glass rounded-3xl p-6 md:p-8 transition duration-500 ease-out hover:shadow-xl hover:-translate-y-1 flex justify-center"
                style="animation-delay: 0.6s;">
                <a class="font-display italic text-2xl md:text-3xl text-gray-800 dark:text-gray-100 hover:text-primary transition-colors duration-300 border-b border-transparent hover:border-primary/30 pb-1"
                    href="mailto:aarohkandy@gmail.com">
                    aarohkandy@gmail.com
                </a>
            </div>
        </div>
    </div>

    <script type="text/babel" src="Cubes.js"></script>
    <script type="text/babel">
        const { useCallback, useEffect, useRef } = React;
        
        const Cubes = ({ gridSize = 10, cubeSize, maxAngle = 45, radius = 3, easing = 'power3.out', duration = { enter: 0.3, leave: 0.6 }, cellGap, borderStyle = '1px solid #fff', faceColor = '#060010', shadow = false, autoAnimate = true, rippleOnClick = true, rippleColor = '#fff', rippleSpeed = 2 }) => {
          const sceneRef = useRef(null);
          const rafRef = useRef(null);
          const idleTimerRef = useRef(null);
          const userActiveRef = useRef(false);
          const simPosRef = useRef({ x: 0, y: 0 });
          const simTargetRef = useRef({ x: 0, y: 0 });
          const simRAFRef = useRef(null);

          const colGap = typeof cellGap === 'number' ? `${cellGap}px` : cellGap?.col !== undefined ? `${cellGap.col}px` : '5%';
          const rowGap = typeof cellGap === 'number' ? `${cellGap}px` : cellGap?.row !== undefined ? `${cellGap.row}px` : '5%';
          const enterDur = duration.enter;
          const leaveDur = duration.leave;

          const tiltAt = useCallback((rowCenter, colCenter) => {
            if (!sceneRef.current) return;
            sceneRef.current.querySelectorAll('.cube').forEach(cube => {
              const r = +cube.dataset.row;
              const c = +cube.dataset.col;
              const dist = Math.hypot(r - rowCenter, c - colCenter);
              if (dist <= radius) {
                const pct = 1 - dist / radius;
                const angle = pct * maxAngle;
                gsap.to(cube, { duration: enterDur, ease: easing, overwrite: true, rotateX: -angle, rotateY: angle });
              } else {
                gsap.to(cube, { duration: leaveDur, ease: 'power3.out', overwrite: true, rotateX: 0, rotateY: 0 });
              }
            });
          }, [radius, maxAngle, enterDur, leaveDur, easing]);

          const onPointerMove = useCallback(e => {
            userActiveRef.current = true;
            if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
            const rect = sceneRef.current.getBoundingClientRect();
            const cellW = rect.width / gridSize;
            const cellH = rect.height / gridSize;
            const colCenter = (e.clientX - rect.left) / cellW;
            const rowCenter = (e.clientY - rect.top) / cellH;
            if (rafRef.current) cancelAnimationFrame(rafRef.current);
            rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));
            idleTimerRef.current = setTimeout(() => { userActiveRef.current = false; }, 3000);
          }, [gridSize, tiltAt]);

          const resetAll = useCallback(() => {
            if (!sceneRef.current) return;
            sceneRef.current.querySelectorAll('.cube').forEach(cube => gsap.to(cube, { duration: leaveDur, rotateX: 0, rotateY: 0, ease: 'power3.out' }));
          }, [leaveDur]);

          const onTouchMove = useCallback(e => {
            e.preventDefault();
            userActiveRef.current = true;
            if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
            const rect = sceneRef.current.getBoundingClientRect();
            const cellW = rect.width / gridSize;
            const cellH = rect.height / gridSize;
            const touch = e.touches[0];
            const colCenter = (touch.clientX - rect.left) / cellW;
            const rowCenter = (touch.clientY - rect.top) / cellH;
            if (rafRef.current) cancelAnimationFrame(rafRef.current);
            rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));
            idleTimerRef.current = setTimeout(() => { userActiveRef.current = false; }, 3000);
          }, [gridSize, tiltAt]);

          const onTouchStart = useCallback(() => { userActiveRef.current = true; }, []);
          const onTouchEnd = useCallback(() => { if (!sceneRef.current) return; resetAll(); }, [resetAll]);

          const onClick = useCallback(e => {
            if (!rippleOnClick || !sceneRef.current) return;
            const rect = sceneRef.current.getBoundingClientRect();
            const cellW = rect.width / gridSize;
            const cellH = rect.height / gridSize;
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const colHit = Math.floor((clientX - rect.left) / cellW);
            const rowHit = Math.floor((clientY - rect.top) / cellH);
            const baseRingDelay = 0.15;
            const baseAnimDur = 0.3;
            const baseHold = 0.6;
            const spreadDelay = baseRingDelay / rippleSpeed;
            const animDuration = baseAnimDur / rippleSpeed;
            const holdTime = baseHold / rippleSpeed;
            const rings = {};
            sceneRef.current.querySelectorAll('.cube').forEach(cube => {
              const r = +cube.dataset.row;
              const c = +cube.dataset.col;
              const dist = Math.hypot(r - rowHit, c - colHit);
              const ring = Math.round(dist);
              if (!rings[ring]) rings[ring] = [];
              rings[ring].push(cube);
            });
            Object.keys(rings).map(Number).sort((a, b) => a - b).forEach(ring => {
              const delay = ring * spreadDelay;
              const faces = rings[ring].flatMap(cube => Array.from(cube.querySelectorAll('.cube-face')));
              gsap.to(faces, { backgroundColor: rippleColor, duration: animDuration, delay, ease: 'power3.out' });
              gsap.to(faces, { backgroundColor: faceColor, duration: animDuration, delay: delay + animDuration + holdTime, ease: 'power3.out' });
            });
          }, [rippleOnClick, gridSize, faceColor, rippleColor, rippleSpeed]);

          useEffect(() => {
            if (!autoAnimate || !sceneRef.current) return;
            simPosRef.current = { x: Math.random() * gridSize, y: Math.random() * gridSize };
            simTargetRef.current = { x: Math.random() * gridSize, y: Math.random() * gridSize };
            const speed = 0.02;
            const loop = () => {
              if (!userActiveRef.current) {
                const pos = simPosRef.current;
                const tgt = simTargetRef.current;
                pos.x += (tgt.x - pos.x) * speed;
                pos.y += (tgt.y - pos.y) * speed;
                tiltAt(pos.y, pos.x);
                if (Math.hypot(pos.x - tgt.x, pos.y - tgt.y) < 0.1) {
                  simTargetRef.current = { x: Math.random() * gridSize, y: Math.random() * gridSize };
                }
              }
              simRAFRef.current = requestAnimationFrame(loop);
            };
            simRAFRef.current = requestAnimationFrame(loop);
            return () => { if (simRAFRef.current != null) cancelAnimationFrame(simRAFRef.current); };
          }, [autoAnimate, gridSize, tiltAt]);

          useEffect(() => {
            const el = sceneRef.current;
            if (!el) return;
            el.addEventListener('pointermove', onPointerMove);
            el.addEventListener('pointerleave', resetAll);
            el.addEventListener('click', onClick);
            el.addEventListener('touchmove', onTouchMove, { passive: false });
            el.addEventListener('touchstart', onTouchStart, { passive: true });
            el.addEventListener('touchend', onTouchEnd, { passive: true });
            return () => {
              el.removeEventListener('pointermove', onPointerMove);
              el.removeEventListener('pointerleave', resetAll);
              el.removeEventListener('click', onClick);
              el.removeEventListener('touchmove', onTouchMove);
              el.removeEventListener('touchstart', onTouchStart);
              el.removeEventListener('touchend', onTouchEnd);
              if (rafRef.current != null) cancelAnimationFrame(rafRef.current);
              if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
            };
          }, [onPointerMove, resetAll, onClick, onTouchMove, onTouchStart, onTouchEnd]);

          const cells = Array.from({ length: gridSize });
          const sceneStyle = {
            gridTemplateColumns: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,
            gridTemplateRows: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,
            columnGap: colGap,
            rowGap: rowGap
          };
          const wrapperStyle = {
            '--cube-face-border': borderStyle,
            '--cube-face-bg': faceColor,
            '--cube-face-shadow': shadow === true ? '0 0 6px rgba(0,0,0,.5)' : shadow || 'none',
            width: '100%',
            height: '100%'
          };

          return React.createElement('div', { className: 'default-animation', style: wrapperStyle },
            React.createElement('div', { ref: sceneRef, className: 'default-animation--scene', style: sceneStyle },
              cells.map((_, r) => cells.map((__, c) => React.createElement('div', { key: `${r}-${c}`, className: 'cube', 'data-row': r, 'data-col': c },
                ['top', 'bottom', 'left', 'right', 'front', 'back'].map(face => React.createElement('div', { key: face, className: `cube-face cube-face--${face}` }))
              )))
            )
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('cubes-root'));
        root.render(React.createElement('div', { style: { height: '100vh', width: '100vw', position: 'relative' } },
          React.createElement(Cubes, { 
            borderStyle: '3px solid rgba(90, 74, 58, 0.5)', 
            gridSize: 20, 
            maxAngle: 180, 
            radius: 2,
            faceColor: 'rgba(196, 178, 153, 0.4)'
          })
        ));
    </script>
</body>

</html>