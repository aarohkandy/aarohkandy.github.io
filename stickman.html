<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Physics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #fff;
            cursor: crosshair;
            user-select: none;
        }

        canvas {
            display: block;
            will-change: transform;
            position: fixed;
            top: 0;
            left: 0;
        }

        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #888;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="debug">GRAVITY: &darr;</div>
    <canvas id="c"></canvas>
    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d', { alpha: false });
        const debug = document.getElementById('debug');

        // --- Configuration ---
        const cfg = {
            gravity: 0.6,
            friction: 0.99, // Air resistance
            groundFriction: 0.9,
            groundBounce: -0.3,
            wallBounce: -0.4,
            iterations: 4,
            jointSolveIterations: 2
        };

        let width, height;
        let frame = 0;

        // --- State ---
        const mouse = { x: -1000, y: -1000 };
        const gravity = { x: 0, y: cfg.gravity, target: cfg.gravity, transition: 0 };
        let antiGravity = false;

        // --- Physics Engine ---
        class Point {
            constructor(x, y, radius = 0, mass = 1) {
                this.x = x;
                this.y = y;
                this.oldx = x;
                this.oldy = y;
                this.radius = radius;
                this.mass = mass;
                this.pinned = false;
            }

            update() {
                if (this.pinned) return;

                // Verlet Integration
                const velX = (this.x - this.oldx) * cfg.friction;
                const velY = (this.y - this.oldy) * cfg.friction;

                this.oldx = this.x;
                this.oldy = this.y;

                this.x += velX + gravity.x;
                this.y += velY + gravity.y;
            }

            // Layer 1: Predictive Boundary
            predictiveBoundary() {
                if (this.pinned) return;
                const velX = this.x - this.oldx;
                const velY = this.y - this.oldy;
                const nextX = this.x + velX;
                const nextY = this.y + velY;

                // Check horizontal walls
                if (nextX < this.radius) {
                    const pen = this.radius - nextX;
                    this.oldx = this.x + velX * cfg.wallBounce; // Reflect
                    this.x = this.radius;
                } else if (nextX > width - this.radius) {
                    const pen = nextX - (width - this.radius);
                    this.oldx = this.x + velX * cfg.wallBounce;
                    this.x = width - this.radius;
                }

                // Check vertical walls (Ground/Ceiling)
                // Determine which is "floor" based on gravity
                const isFloor = nextY > height - this.radius;
                const isCeiling = nextY < this.radius;

                if (isFloor) {
                    this.onGroundCollision(velX, velY, height - this.radius, 1);
                } else if (isCeiling) {
                    this.onGroundCollision(velX, velY, this.radius, -1);
                }
            }

            onGroundCollision(vx, vy, limit, dir) {
                // Bounce
                this.oldy = this.y + vy * cfg.groundBounce;
                this.y = limit;

                // Friction
                const newVx = vx * cfg.groundFriction;
                this.oldx = this.x - newVx;

                // Anti-jitter
                if (Math.abs(vy) < 0.5) {
                    this.oldy = this.y; // Stop
                }
            }

            // Layer 2: Hard Clamp
            clamp() {
                this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));
            }
        }

        class Stick {
            constructor(p1, p2, length) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = length || Math.hypot(p1.x - p2.x, p1.y - p2.y);
            }

            resolve() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return; // Prevent division by zero

                const diff = (dist - this.length) / dist;
                const moveX = dx * diff * 0.5;
                const moveY = dy * diff * 0.5;

                if (!this.p1.pinned) {
                    this.p1.x += moveX;
                    this.p1.y += moveY;
                }
                if (!this.p2.pinned) {
                    this.p2.x -= moveX;
                    this.p2.y -= moveY;
                }
            }
        }

        // --- Stickman Structure ---
        const stickman = {
            points: {},
            sticks: [],
            angles: [] // { p1, pivot, p2, min, max }
        };

        function createStickman(startX, startY) {
            // Topology
            // Head (radius 20)
            const head = new Point(startX, startY - 100, 20); // P0
            // Neck/Shoulder junction
            const shoulder = new Point(startX, startY - 80, 0); // P1
            // Pelvis
            const pelvis = new Point(startX, startY - 20, 0); // P2

            // Arms
            const lElbow = new Point(startX - 35, startY - 80, 3); // P3
            const lHand = new Point(startX - 65, startY - 80, 4); // P4
            const rElbow = new Point(startX + 35, startY - 80, 3); // P5
            const rHand = new Point(startX + 65, startY - 80, 4); // P6

            // Legs
            const lKnee = new Point(startX - 10, startY + 20, 3); // P7
            const lFoot = new Point(startX - 10, startY + 55, 4); // P8
            const rKnee = new Point(startX + 10, startY + 20, 3); // P9
            const rFoot = new Point(startX + 10, startY + 55, 4); // P10

            stickman.points = { head, shoulder, pelvis, lElbow, lHand, rElbow, rHand, lKnee, lFoot, rKnee, rFoot };
            const pts = stickman.points;

            // Body (60px)
            stickman.sticks.push(new Stick(pts.head, pts.shoulder, 20)); // Neck
            stickman.sticks.push(new Stick(pts.shoulder, pts.pelvis, 60)); // Spine

            // Shoulders to Arms (connect directly for visual simplicity, logic separates)
            stickman.sticks.push(new Stick(pts.shoulder, pts.lElbow, 35));
            stickman.sticks.push(new Stick(pts.lElbow, pts.lHand, 30));
            stickman.sticks.push(new Stick(pts.shoulder, pts.rElbow, 35));
            stickman.sticks.push(new Stick(pts.rElbow, pts.rHand, 30));

            // Pelvis to Legs
            stickman.sticks.push(new Stick(pts.pelvis, pts.lKnee, 40));
            stickman.sticks.push(new Stick(pts.lKnee, pts.lFoot, 35));
            stickman.sticks.push(new Stick(pts.pelvis, pts.rKnee, 40));
            stickman.sticks.push(new Stick(pts.rKnee, pts.rFoot, 35));

            // Angle Constraints
            // Helper to add constraint: pivot is central point. angle is roughly relative
            // Elbows: 0 to 170
            stickman.angles.push({ p1: pts.shoulder, pivot: pts.lElbow, p2: pts.lHand, min: 0.1, max: 2.8 });
            stickman.angles.push({ p1: pts.shoulder, pivot: pts.rElbow, p2: pts.rHand, min: 0.1, max: 2.8, flip: true });

            // Knees: 0 to 160 (prevent backward bend)
            stickman.angles.push({ p1: pts.pelvis, pivot: pts.lKnee, p2: pts.lFoot, min: 0, max: 2.8 });
            stickman.angles.push({ p1: pts.pelvis, pivot: pts.rKnee, p2: pts.rFoot, min: 0, max: 2.8 });

            // Head: limited rotation
            stickman.angles.push({ p1: pts.pelvis, pivot: pts.shoulder, p2: pts.head, min: -0.8, max: 0.8 });
        }

        // --- Interaction ---
        function applyInteraction() {
            const pts = stickman.points;
            const center = pts.pelvis;
            const gravityDir = antiGravity ? 1 : -1;

            // Alive Balance: Torque to keep standing
            const bal = (center.x - pts.head.x) * 0.2;
            pts.head.x += bal;
            pts.shoulder.x += bal * 0.5;

            const dx = mouse.x - center.x; // Inverted: points towards mouse
            const dy = mouse.y - center.y;
            const distSq = dx * dx + dy * dy;

            if (distSq < 100000) { // ATTRACTION ZONE
                const dist = Math.sqrt(distSq);
                const nx = dx / dist;
                const ny = dy / dist;

                if (dist < 100) { // HUG ZONE
                    let f = (120 - dist) * 0.2; // Gentle pull
                    Object.values(pts).forEach(p => {
                        p.x += nx * f;
                        p.y += ny * f;
                    });

                    // Hug Pose
                    const reachSpeed = 0.2;
                    pts.lHand.x += (mouse.x - pts.lHand.x) * reachSpeed;
                    pts.lHand.y += (mouse.y - pts.lHand.y) * reachSpeed;
                    pts.rHand.x += (mouse.x - pts.rHand.x) * reachSpeed;
                    pts.rHand.y += (mouse.y - pts.rHand.y) * reachSpeed;

                } else if (dist < 300) { // REACH ZONE
                    // Lean body towards mouse
                    pts.head.x += (dx > 0 ? 3 : -3) * (1 / (dist / 100));

                    // Reach hands towards mouse
                    const reachSpeed = 0.05;
                    pts.lHand.x += (mouse.x - pts.lHand.x) * reachSpeed;
                    pts.lHand.y += (mouse.y - pts.lHand.y) * reachSpeed;
                    pts.rHand.x += (mouse.x - pts.rHand.x) * reachSpeed;
                    pts.rHand.y += (mouse.y - pts.rHand.y) * reachSpeed;
                }
            } else if (distSq < 400000) { // WATCH (Long range)
                pts.head.x += (mouse.x - pts.head.x) * 0.1;
                pts.head.y += (mouse.y - pts.head.y) * 0.1;
            }
        }

        function resolveAngles() {
            // Very simple geometric constraint
            // If angle is out of bounds, push outer points back
            for (let c of stickman.angles) {
                const a1 = Math.atan2(c.p1.y - c.pivot.y, c.p1.x - c.pivot.x);
                const a2 = Math.atan2(c.p2.y - c.pivot.y, c.p2.x - c.pivot.x);
                let angle = a2 - a1;

                // Normalize -PI to PI
                while (angle <= -Math.PI) angle += Math.PI * 2;
                while (angle > Math.PI) angle -= Math.PI * 2;
            }
        }

        // --- Core Loop ---
        function update() {
            frame++;

            // Antigravity Transition
            if (gravity.transition > 0) {
                gravity.transition--;
                const t = 1 - (gravity.transition / 18); // 0 to 1
                const ease = 1 - Math.pow(1 - t, 3); // EaseOutCubic
                gravity.y = gravity.start + (gravity.target - gravity.start) * ease;
            } else {
                gravity.y = gravity.target;
            }

            if (frame % 3 === 0) applyInteraction();

            // 1. Update Positions
            const points = Object.values(stickman.points);

            // Predictive Boundary (Layer 1) & Update
            points.forEach(p => {
                p.predictiveBoundary();
                p.update();
            });

            // 2. Solve Constraints
            for (let i = 0; i < cfg.iterations; i++) {
                stickman.sticks.forEach(s => s.resolve());
                // Hard Clamp (Layer 2)
                points.forEach(p => p.clamp());
            }

            // 3. Joint Preservation (Layer 3)
            for (let i = 0; i < cfg.jointSolveIterations; i++) {
                stickman.sticks.forEach(s => s.resolve());
            }

            // Animation States (Idle / Fall)
            const COG = stickman.points.pelvis;
            const speed = Math.abs(COG.x - COG.oldx) + Math.abs(COG.y - COG.oldy);

            if (speed < 0.5) {
                // Idle breathe
                const breath = Math.sin(frame * 0.05) * 0.5;
                stickman.points.head.y += breath;
            }

            draw();
            requestAnimationFrame(update);
        }

        // --- Rendering ---
        function draw() {
            // Clean Optimized Clear
            ctx.clearRect(0, 0, width, height);

            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;

            ctx.beginPath();
            stickman.sticks.forEach(s => {
                ctx.moveTo(s.p1.x, s.p1.y);
                ctx.lineTo(s.p2.x, s.p2.y);
            });
            ctx.stroke();

            // Head
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.arc(stickman.points.head.x, stickman.points.head.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }

        // --- Inputs ---
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // Immediate clamp
            Object.values(stickman.points).forEach(p => p.clamp());
        });

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        window.addEventListener('keydown', e => {
            if (e.code === 'Space' || e.key === 'g' || e.key === 'G') {
                toggleGravity();
            }
        });

        function toggleGravity() {
            antiGravity = !antiGravity;
            gravity.start = gravity.y;
            // cfg.gravity is 0.6
            gravity.target = antiGravity ? -cfg.gravity : cfg.gravity;
            gravity.transition = 18;
            debug.innerHTML = `GRAVITY: ${antiGravity ? '&uarr;' : '&darr;'}`;
        }

        // Init
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        createStickman(width / 2, height - 120);
        update();

    </script>
</body>

</html>